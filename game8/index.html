<!-- Copyright (c) 2025 IRAKLI IVANISHVILI Neon Night Runner -->
<!-- All rights reserved. Unauthorized use is prohibited. See LICENSE file for details. -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Night Runner</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            font-family: monospace;
            overflow: hidden;
            color: #00ffff;
        }
        
        canvas {
            display: block;
            background: linear-gradient(180deg, #001122 0%, #000511 100%);
        }
        
        .hud {
            position: absolute;
            pointer-events: none;
            font-weight: bold;
            text-shadow: 0 0 10px currentColor;
        }
        
        .score {
            top: 20px;
            right: 20px;
            font-size: 24px;
            color: #00ffff;
        }
        
        .speed {
            bottom: 20px;
            left: 20px;
            font-size: 18px;
            color: #ff00ff;
        }
        
        .controls {
            bottom: 20px;
            right: 20px;
            font-size: 12px;
            color: #ffff00;
            line-height: 1.4;
            text-align: right;
        }
        
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #ff4444;
            font-size: 32px;
            text-shadow: 0 0 20px currentColor;
            pointer-events: auto;
        }
        
        .play-again {
            margin-top: 20px;
            padding: 15px 30px;
            font-size: 18px;
            background: linear-gradient(45deg, #ff00ff, #00ffff);
            border: none;
            border-radius: 5px;
            color: #000;
            cursor: pointer;
            font-weight: bold;
            text-shadow: none;
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.5);
        }
        
        .play-again:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(255, 0, 255, 0.8);
        }
        
        .instructions {
            margin-top: 20px;
            padding: 20px;
            background: #111;
            color: #00ffff;
            font-family: monospace;
            border: 2px solid #00ffff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }
        
        .instructions h2 {
            color: #ff00ff;
            text-shadow: 0 0 10px currentColor;
            margin-top: 0;
        }
        
        .instructions ul {
            list-style: none;
            padding: 0;
        }
        
        .instructions li {
            margin: 10px 0;
            padding: 5px;
            background: rgba(0, 255, 255, 0.1);
            border-left: 3px solid #00ffff;
            padding-left: 15px;
        }
    </style>
</head>
<body>

    <button onclick="window.location.href='../index.html'" style="position: absolute; top: 20px; left: 20px; z-index: 999; padding: 10px 16px; background-color: #333; color: white; border: none; border-radius: 6px; cursor: pointer;">
    ⬅ Main Menu
  </button>

    <canvas id="gameCanvas"></canvas>
    
    <!-- HUD Elements -->
    <div class="hud score" id="score">SCORE: 0</div>
    <div class="hud speed" id="speed">SPEED: 100</div>
    <div class="hud controls">
        CONTROLS:<br>
        ↑ Accelerate<br>
        ↓ Slow Down<br>
        ← / → Steer<br>
        ESC Pause
    </div>
    
    <!-- Game Over Screen -->
    <div class="game-over" id="gameOver" style="display: none;">
        <div>GAME OVER</div>
        <div style="font-size: 18px; margin: 10px 0;">FINAL SCORE: <span id="finalScore">0</span></div>
        <button class="play-again" onclick="restartGame()">PLAY AGAIN</button>
    </div>

    <script>
        // Game canvas and context
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Resize canvas to full window
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Game state
        let gameState = {
            running: true,
            paused: false,
            score: 0,
            speed: 100,
            playerX: canvas.width / 2,
            playerY: canvas.height * 0.8,
            playerVelocityX: 0,
            playerVelocityY: 0,
            cameraShake: 0,
            oilSlideTime: 0
        };
        
        // Input handling
        const keys = {};
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            if (e.key === 'Escape') {
                gameState.paused = !gameState.paused;
            }
        });
        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });
        
        // Game objects arrays
        let vehicles = [];
        let obstacles = [];
        let orbs = [];
        let raindrops = [];
        let particles = [];
        
        // Utility functions
        function random(min, max) {
            return Math.random() * (max - min) + min;
        }
        
        function distance(x1, y1, x2, y2) {
            return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        }
        
        // Particle system
        class Particle {
            constructor(x, y, vx, vy, color, life) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.color = color;
                this.life = life;
                this.maxLife = life;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life--;
                this.vy += 0.1; // gravity
            }
            
            draw() {
                const alpha = this.life / this.maxLife;
                ctx.globalAlpha = alpha;
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - 1, this.y - 1, 2, 2);
                ctx.globalAlpha = 1;
            }
        }
        
        // Vehicle class
        class Vehicle {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.speed = random(2, 4);
                this.width = type === 'truck' ? 40 : type === 'van' ? 30 : 25;
                this.height = type === 'truck' ? 80 : type === 'van' ? 60 : 50;
            }
            
            update() {
                this.y += this.speed + gameState.speed / 20;
            }
            
            draw() {
                ctx.save();
                
                // Vehicle shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(this.x - this.width/2 + 2, this.y - this.height/2 + 2, this.width, this.height);
                
                // Vehicle body
                const gradient = ctx.createLinearGradient(this.x - this.width/2, this.y - this.height/2, this.x + this.width/2, this.y + this.height/2);
                if (this.type === 'truck') {
                    gradient.addColorStop(0, '#444');
                    gradient.addColorStop(1, '#222');
                } else if (this.type === 'van') {
                    gradient.addColorStop(0, '#333');
                    gradient.addColorStop(1, '#111');
                } else {
                    gradient.addColorStop(0, '#555');
                    gradient.addColorStop(1, '#333');
                }
                
                ctx.fillStyle = gradient;
                ctx.fillRect(this.x - this.width/2, this.y - this.height/2, this.width, this.height);
                
                // Headlights
                ctx.fillStyle = '#ffffaa';
                ctx.fillRect(this.x - this.width/2 + 5, this.y - this.height/2, 8, 4);
                ctx.fillRect(this.x + this.width/2 - 13, this.y - this.height/2, 8, 4);
                
                // Taillights
                ctx.fillStyle = '#ff4444';
                ctx.fillRect(this.x - this.width/2 + 5, this.y + this.height/2 - 4, 8, 4);
                ctx.fillRect(this.x + this.width/2 - 13, this.y + this.height/2 - 4, 8, 4);
                
                ctx.restore();
            }
        }
        
        // Obstacle class
        class Obstacle {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.width = type === 'oil' ? 60 : 20;
                this.height = type === 'oil' ? 40 : 20;
            }
            
            update() {
                this.y += gameState.speed / 15;
            }
            
            draw() {
                ctx.save();
                
                if (this.type === 'cone') {
                    // Traffic cone
                    ctx.fillStyle = '#ff6600';
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y - 15);
                    ctx.lineTo(this.x - 8, this.y + 15);
                    ctx.lineTo(this.x + 8, this.y + 15);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(this.x - 6, this.y, 12, 3);
                } else if (this.type === 'oil') {
                    // Oil slick
                    const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, 30);
                    gradient.addColorStop(0, 'rgba(50, 50, 50, 0.8)');
                    gradient.addColorStop(1, 'rgba(20, 20, 20, 0.3)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.ellipse(this.x, this.y, 30, 20, 0, 0, Math.PI * 2);
                    ctx.fill();
                } else if (this.type === 'puddle') {
                    // Water puddle
                    const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, 25);
                    gradient.addColorStop(0, 'rgba(0, 100, 150, 0.6)');
                    gradient.addColorStop(1, 'rgba(0, 50, 100, 0.2)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.ellipse(this.x, this.y, 25, 15, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }
        
        // Energy orb class
        class EnergyOrb {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.pulse = 0;
                this.collected = false;
            }
            
            update() {
                this.y += gameState.speed / 10;
                this.pulse += 0.2;
            }
            
            draw() {
                if (this.collected) return;
                
                const glowSize = 15 + Math.sin(this.pulse) * 5;
                
                // Outer glow
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, glowSize);
                gradient.addColorStop(0, 'rgba(0, 255, 255, 0.8)');
                gradient.addColorStop(0.5, 'rgba(0, 255, 255, 0.4)');
                gradient.addColorStop(1, 'rgba(0, 255, 255, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, glowSize, 0, Math.PI * 2);
                ctx.fill();
                
                // Core
                ctx.fillStyle = '#00ffff';
                ctx.beginPath();
                ctx.arc(this.x, this.y, 6, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Rain effect
        function createRain() {
            for (let i = 0; i < 3; i++) {
                raindrops.push({
                    x: random(0, canvas.width),
                    y: random(-canvas.height, 0),
                    speed: random(5, 15),
                    length: random(10, 30),
                    opacity: random(0.1, 0.3)
                });
            }
        }
        
        function updateRain() {
            for (let i = raindrops.length - 1; i >= 0; i--) {
                const drop = raindrops[i];
                drop.y += drop.speed + gameState.speed / 10;
                
                if (drop.y > canvas.height + drop.length) {
                    raindrops.splice(i, 1);
                }
            }
        }
        
        function drawRain() {
            ctx.save();
            for (const drop of raindrops) {
                ctx.globalAlpha = drop.opacity;
                ctx.strokeStyle = '#aaf';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(drop.x, drop.y);
                ctx.lineTo(drop.x - 2, drop.y + drop.length);
                ctx.stroke();
            }
            ctx.globalAlpha = 1;
            ctx.restore();
        }
        
        // Spawn functions
        function spawnVehicle() {
            if (Math.random() < 0.02) {
                const types = ['car', 'van', 'truck'];
                const type = types[Math.floor(Math.random() * types.length)];
                const x = random(100, canvas.width - 100);
                vehicles.push(new Vehicle(x, -50, type));
            }
        }
        
        function spawnObstacle() {
            if (Math.random() < 0.005) {
                const types = ['cone', 'oil', 'puddle'];
                const type = types[Math.floor(Math.random() * types.length)];
                const x = random(100, canvas.width - 100);
                obstacles.push(new Obstacle(x, -50, type));
            }
        }
        
        function spawnOrb() {
            if (Math.random() < 0.01) {
                const x = random(100, canvas.width - 100);
                orbs.push(new EnergyOrb(x, -30));
            }
        }
        
        // Collision detection
        function checkCollisions() {
            const playerRect = {
                x: gameState.playerX - 15,
                y: gameState.playerY - 25,
                width: 30,
                height: 50
            };
            
            // Check vehicle collisions
            for (const vehicle of vehicles) {
                const vehicleRect = {
                    x: vehicle.x - vehicle.width / 2,
                    y: vehicle.y - vehicle.height / 2,
                    width: vehicle.width,
                    height: vehicle.height
                };
                
                if (playerRect.x < vehicleRect.x + vehicleRect.width &&
                    playerRect.x + playerRect.width > vehicleRect.x &&
                    playerRect.y < vehicleRect.y + vehicleRect.height &&
                    playerRect.y + playerRect.height > vehicleRect.y) {
                    
                    // Game over
                    gameState.running = false;
                    document.getElementById('gameOver').style.display = 'block';
                    document.getElementById('finalScore').textContent = gameState.score;
                    return;
                }
                
                // Camera shake when close
                const dist = distance(gameState.playerX, gameState.playerY, vehicle.x, vehicle.y);
                if (dist < 60) {
                    gameState.cameraShake = Math.max(gameState.cameraShake, 3);
                }
            }
            
            // Check obstacle collisions
            for (const obstacle of obstacles) {
                const dist = distance(gameState.playerX, gameState.playerY, obstacle.x, obstacle.y);
                
                if (dist < 25) {
                    if (obstacle.type === 'oil') {
                        gameState.oilSlideTime = 120; // 2 seconds at 60fps
                        obstacles.splice(obstacles.indexOf(obstacle), 1);
                    } else if (obstacle.type === 'puddle') {
                        // Create splash particles
                        for (let i = 0; i < 10; i++) {
                            particles.push(new Particle(
                                obstacle.x + random(-10, 10),
                                obstacle.y,
                                random(-3, 3),
                                random(-8, -3),
                                '#4488ff',
                                30
                            ));
                        }
                        obstacles.splice(obstacles.indexOf(obstacle), 1);
                    } else {
                        // Solid obstacle - game over
                        gameState.running = false;
                        document.getElementById('gameOver').style.display = 'block';
                        document.getElementById('finalScore').textContent = gameState.score;
                        return;
                    }
                }
            }
            
            // Check orb collection
            for (const orb of orbs) {
                if (!orb.collected) {
                    const dist = distance(gameState.playerX, gameState.playerY, orb.x, orb.y);
                    if (dist < 20) {
                        orb.collected = true;
                        gameState.score += 50;
                        
                        // Collection particles
                        for (let i = 0; i < 8; i++) {
                            particles.push(new Particle(
                                orb.x,
                                orb.y,
                                random(-4, 4),
                                random(-4, 4),
                                '#00ffff',
                                20
                            ));
                        }
                    }
                }
            }
        }
        
        // Player update
        function updatePlayer() {
            // Handle oil slide effect
            if (gameState.oilSlideTime > 0) {
                gameState.oilSlideTime--;
            }
            
            const controlSensitivity = gameState.oilSlideTime > 0 ? 0.3 : 1.0;
            
            // Handle input
            if (keys['ArrowUp'] || keys['w']) {
                gameState.speed = Math.min(gameState.speed + 2, 200);
            }
            if (keys['ArrowDown'] || keys['s']) {
                gameState.speed = Math.max(gameState.speed - 2, 50);
            }
            if (keys['ArrowLeft'] || keys['a']) {
                gameState.playerVelocityX -= 0.8 * controlSensitivity;
            }
            if (keys['ArrowRight'] || keys['d']) {
                gameState.playerVelocityX += 0.8 * controlSensitivity;
            }
            
            // Apply movement with friction
            gameState.playerVelocityX *= 0.9;
            gameState.playerX += gameState.playerVelocityX;
            
            // Keep player on screen
            gameState.playerX = Math.max(30, Math.min(canvas.width - 30, gameState.playerX));
            
            // Gradual speed increase
            gameState.speed += 0.02;
            
            // Update score
            gameState.score += Math.floor(gameState.speed / 10);
        }
        
        // Draw player (hoverbike)
        function drawPlayer() {
            ctx.save();
            
            // Apply camera shake
            if (gameState.cameraShake > 0) {
                ctx.translate(random(-gameState.cameraShake, gameState.cameraShake), 
                             random(-gameState.cameraShake, gameState.cameraShake));
                gameState.cameraShake--;
            }
            
            const x = gameState.playerX;
            const y = gameState.playerY;
            
            // Headlight beam
            const gradient = ctx.createRadialGradient(x, y - 20, 0, x, y - 100, 60);
            gradient.addColorStop(0, 'rgba(255, 255, 200, 0.3)');
            gradient.addColorStop(1, 'rgba(255, 255, 200, 0)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(x, y - 60, 60, 0, Math.PI * 2);
            ctx.fill();
            
            // Bike shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.fillRect(x - 15 + 2, y - 25 + 2, 30, 50);
            
            // Bike body
            const bikeGradient = ctx.createLinearGradient(x - 15, y - 25, x + 15, y + 25);
            bikeGradient.addColorStop(0, '#666');
            bikeGradient.addColorStop(0.5, '#999');
            bikeGradient.addColorStop(1, '#333');
            
            ctx.fillStyle = bikeGradient;
            ctx.fillRect(x - 15, y - 25, 30, 50);
            
            // Neon accents
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 2;
            ctx.strokeRect(x - 12, y - 20, 24, 40);
            
            // Headlight
            ctx.fillStyle = '#ffffaa';
            ctx.fillRect(x - 8, y - 27, 16, 6);
            
            // Exhaust particles
            if (Math.random() < 0.3) {
                particles.push(new Particle(
                    x + random(-5, 5),
                    y + 25,
                    random(-1, 1),
                    random(2, 5),
                    '#4488ff',
                    15
                ));
            }
            
            ctx.restore();
        }
        
        // Draw road
        function drawRoad() {
            // Wet asphalt effect
            const roadGradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
            roadGradient.addColorStop(0, '#1a1a2e');
            roadGradient.addColorStop(0.5, '#16213e');
            roadGradient.addColorStop(1, '#1a1a2e');
            
            ctx.fillStyle = roadGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Road lines
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 2;
            
            // Center line
            ctx.setLineDash([20, 20]);
            ctx.beginPath();
            ctx.moveTo(canvas.width / 2, 0);
            ctx.lineTo(canvas.width / 2, canvas.height);
            ctx.stroke();
            
            // Side lines
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.moveTo(50, 0);
            ctx.lineTo(50, canvas.height);
            ctx.moveTo(canvas.width - 50, 0);
            ctx.lineTo(canvas.width - 50, canvas.height);
            ctx.stroke();
        }
        
        // Main game loop
        function gameLoop() {
            if (!gameState.running) return;
            
            if (!gameState.paused) {
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw background
                drawRoad();
                
                // Update rain
                createRain();
                updateRain();
                drawRain();
                
                // Spawn objects
                spawnVehicle();
                spawnObstacle();
                spawnOrb();
                
                // Update player
                updatePlayer();
                
                // Update and draw vehicles
                for (let i = vehicles.length - 1; i >= 0; i--) {
                    vehicles[i].update();
                    vehicles[i].draw();
                    
                    if (vehicles[i].y > canvas.height + 100) {
                        vehicles.splice(i, 1);
                    }
                }
                
                // Update and draw obstacles
                for (let i = obstacles.length - 1; i >= 0; i--) {
                    obstacles[i].update();
                    obstacles[i].draw();
                    
                    if (obstacles[i].y > canvas.height + 50) {
                        obstacles.splice(i, 1);
                    }
                }
                
                // Update and draw orbs
                for (let i = orbs.length - 1; i >= 0; i--) {
                    orbs[i].update();
                    orbs[i].draw();
                    
                    if (orbs[i].y > canvas.height + 50 || orbs[i].collected) {
                        orbs.splice(i, 1);
                    }
                }
                
                // Update and draw particles
                for (let i = particles.length - 1; i >= 0; i--) {
                    particles[i].update();
                    particles[i].draw();
                    
                    if (particles[i].life <= 0) {
                        particles.splice(i, 1);
                    }
                }
                
                // Draw player
                drawPlayer();
                
                // Check collisions
                checkCollisions();
                
                // Update HUD
                document.getElementById('score').textContent = `SCORE: ${gameState.score}`;
                document.getElementById('speed').textContent = `SPEED: ${Math.floor(gameState.speed)}`;
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        // Restart game function
        function restartGame() {
            gameState = {
                running: true,
                paused: false,
                score: 0,
                speed: 100,
                playerX: canvas.width / 2,
                playerY: canvas.height * 0.8,
                playerVelocityX: 0,
                playerVelocityY: 0,
                cameraShake: 0,
                oilSlideTime: 0
            };
            
            vehicles = [];
            obstacles = [];
            orbs = [];
            raindrops = [];
            particles = [];
            
            document.getElementById('gameOver').style.display = 'none';
            gameLoop();
        }
        
        // Start the game
        gameLoop();
    </script>
    
    <!-- Game Instructions -->
    <div class="instructions">
        <h2>🌆 NEON NIGHT RUNNER - Game Instructions</h2>
        <ul>
            <li><strong>🎯 Objective:</strong> Control a futuristic hoverbike through endless neon-lit streets, dodging traffic and collecting energy orbs.</li>
            <li><strong>🕹️ Controls:</strong>
                <ul>
                    <li>↑ Arrow Key / W - Accelerate forward</li>
                    <li>↓ Arrow Key / S - Slow down</li>
                    <li>← → Arrow Keys / A D - Steer left/right</li>
                    <li>ESC - Pause/unpause game</li>
                </ul>
            </li>
            <li><strong>⚡ Energy Orbs:</strong> Collect glowing cyan orbs to increase your score (+50 points each)</li>
            <li><strong>🚗 Traffic:</strong> Avoid colliding with cars, vans, and trucks moving toward you</li>
            <li><strong>🚧 Obstacles:</strong>
                <ul>
                    <li>Orange Cones - Solid obstacles that end the game on collision</li>
                    <li>Oil Slicks - Make your bike slide and reduce control for 2 seconds</li>
                    <li>Water Puddles - Create splash effects but are harmless to pass through</li>
                </ul>
            </li>
            <li><strong>📈 Scoring:</strong> Points awarded for distance traveled and energy orbs collected</li>
            <li><strong>🎮 Gameplay:</strong> Speed gradually increases over time. Game ends when you collide with traffic or solid obstacles.</li>
            <li><strong>🌧️ Atmosphere:</strong> Experience realistic wet streets with falling rain, neon lighting effects, and cyberpunk aesthetics!</li>
        </ul>
    </div>
</body>
</html>
