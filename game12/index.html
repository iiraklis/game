<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crystal Runner - Temple Adventure</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            color: white;
        }
        
        #gameCanvas {
            border: 3px solid #gold;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
            max-width: 100%;
            height: auto;
        }
        
        #instructions {
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            text-align: center;
            font-size: 14px;
            max-width: 600px;
        }
        
        .control-key {
            display: inline-block;
            padding: 3px 8px;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid white;
            border-radius: 4px;
            margin: 0 3px;
        }
    </style>
</head>
<body>
    <button onclick="window.location.href='../index.html'" style="position: absolute; top: 20px; left: 20px; z-index: 999; padding: 10px 16px; background-color: #333; color: white; border: none; border-radius: 6px; cursor: pointer;">
    ‚¨Ö Main Menu
  </button>

    <canvas id="gameCanvas"></canvas>
    <div id="instructions">
        <h3>üéÆ Crystal Runner Controls</h3>
        <p>
            <span class="control-key">‚Üê</span><span class="control-key">‚Üí</span> Move left/right |
            <span class="control-key">‚Üë</span> or <span class="control-key">Space</span> Jump |
            <span class="control-key">‚Üì</span> Slide |
            <span class="control-key">Esc</span> Pause/Resume
        </p>
        <p>üíé Collect crystals to earn points. Avoid traps! üíÄ</p>
    </div>

    <script>
        // Game setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Canvas sizing
        canvas.width = 900;
        canvas.height = 500;
        
        // Game state
        let gameState = 'playing'; // 'playing', 'paused', 'gameover'
        let score = 0;
        let lives = 3;
        let gameSpeed = 2;
        let frameCount = 0;
        
        // Sound system (using Web Audio API for generated sounds)
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSound(type) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            switch(type) {
                case 'jump':
                    oscillator.frequency.value = 400;
                    oscillator.type = 'sine';
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.1);
                    break;
                case 'collect':
                    oscillator.frequency.value = 800;
                    oscillator.type = 'sine';
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.3);
                    break;
                case 'gameover':
                    oscillator.frequency.value = 200;
                    oscillator.type = 'sawtooth';
                    gainNode.gain.setValueAtTime(0.4, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.5);
                    break;
            }
        }
        
        // Particle system
        class Particle {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.life = 1;
                
                if (type === 'crystal') {
                    this.vx = (Math.random() - 0.5) * 4;
                    this.vy = Math.random() * -3 - 1;
                    this.color = `hsl(${Math.random() * 60 + 180}, 100%, 70%)`;
                    this.size = Math.random() * 3 + 2;
                } else if (type === 'dust') {
                    this.vx = (Math.random() - 0.5) * 2;
                    this.vy = Math.random() * -1;
                    this.color = 'rgba(139, 69, 19, 0.5)';
                    this.size = Math.random() * 4 + 2;
                }
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += 0.1; // gravity
                this.life -= 0.02;
                
                if (this.type === 'crystal') {
                    this.size *= 0.98;
                }
            }
            
            draw() {
                ctx.save();
                ctx.globalAlpha = this.life;
                
                if (this.type === 'crystal') {
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = this.color;
                }
                
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }
        
        let particles = [];
        
        // Player object
        const player = {
            x: 150,
            y: 300,
            width: 30,
            height: 40,
            vx: 0,
            vy: 0,
            jumping: false,
            sliding: false,
            grounded: false,
            animFrame: 0
        };
        
        // Platforms
        class Platform {
            constructor(x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
            }
            
            draw() {
                // Stone platform
                ctx.fillStyle = '#4a4a4a';
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                // Platform details
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x, this.y, this.width, this.height);
                
                // Cracks
                ctx.strokeStyle = '#222';
                ctx.lineWidth = 1;
                for (let i = 0; i < 3; i++) {
                    let crackX = this.x + Math.random() * this.width;
                    ctx.beginPath();
                    ctx.moveTo(crackX, this.y);
                    ctx.lineTo(crackX + Math.random() * 10 - 5, this.y + this.height);
                    ctx.stroke();
                }
            }
        }
        
        // Crystal collectible
        class Crystal {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 20;
                this.height = 20;
                this.collected = false;
                this.rotation = 0;
                this.float = 0;
            }
            
            update() {
                this.rotation += 0.05;
                this.float = Math.sin(frameCount * 0.05) * 5;
            }
            
            draw() {
                if (this.collected) return;
                
                ctx.save();
                ctx.translate(this.x + this.width/2, this.y + this.height/2 + this.float);
                ctx.rotate(this.rotation);
                
                // Glow effect
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#00ffff';
                
                // Crystal shape
                ctx.fillStyle = '#00ffff';
                ctx.beginPath();
                ctx.moveTo(0, -10);
                ctx.lineTo(10, 0);
                ctx.lineTo(0, 10);
                ctx.lineTo(-10, 0);
                ctx.closePath();
                ctx.fill();
                
                // Inner shine
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.beginPath();
                ctx.moveTo(0, -5);
                ctx.lineTo(5, 0);
                ctx.lineTo(0, 5);
                ctx.lineTo(-5, 0);
                ctx.closePath();
                ctx.fill();
                
                ctx.restore();
            }
        }
        
        // Trap/Spike
        class Spike {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 30;
                this.height = 25;
            }
            
            draw() {
                ctx.fillStyle = '#666';
                ctx.strokeStyle = '#444';
                
                // Draw 3 spikes
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    let spikeX = this.x + i * 10 + 5;
                    ctx.moveTo(spikeX - 4, this.y + this.height);
                    ctx.lineTo(spikeX + 4, this.y + this.height);
                    ctx.lineTo(spikeX, this.y);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                }
            }
        }
        
        // Game objects arrays
        let platforms = [];
        let crystals = [];
        let spikes = [];
        let backgroundOffset = 0;
        
        // Initialize level
        function initLevel() {
            // Ground platforms
            for (let i = 0; i < 20; i++) {
                platforms.push(new Platform(i * 100, 400, 100, 100));
            }
            
            // Floating platforms
            platforms.push(new Platform(300, 320, 80, 20));
            platforms.push(new Platform(500, 280, 100, 20));
            platforms.push(new Platform(700, 250, 80, 20));
            platforms.push(new Platform(900, 300, 120, 20));
            platforms.push(new Platform(1100, 350, 80, 20));
            
            // Crystals
            for (let i = 0; i < 15; i++) {
                crystals.push(new Crystal(300 + i * 150, 250 + Math.random() * 100));
            }
            
            // Spikes
            spikes.push(new Spike(400, 375));
            spikes.push(new Spike(650, 375));
            spikes.push(new Spike(850, 375));
            spikes.push(new Spike(1050, 375));
        }
        
        // Input handling
        const keys = {};
        
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            
            if (e.key === 'Escape') {
                if (gameState === 'playing') {
                    gameState = 'paused';
                } else if (gameState === 'paused') {
                    gameState = 'playing';
                }
            }
            
            if ((e.key === ' ' || e.key === 'ArrowUp') && player.grounded && gameState === 'playing') {
                player.vy = -12;
                player.jumping = true;
                player.grounded = false;
                playSound('jump');
                
                // Dust particles on jump
                for (let i = 0; i < 5; i++) {
                    particles.push(new Particle(player.x + player.width/2, player.y + player.height, 'dust'));
                }
            }
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
            if (e.key === 'ArrowDown') {
                player.sliding = false;
            }
        });
        
        // Collision detection
        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }
        
        // Update game
        function update() {
            if (gameState !== 'playing') return;
            
            frameCount++;
            
            // Player movement
            if (keys['ArrowLeft']) {
                player.vx = -5;
            } else if (keys['ArrowRight']) {
                player.vx = 5;
            } else {
                player.vx *= 0.8;
            }
            
            if (keys['ArrowDown']) {
                player.sliding = true;
            } else {
                player.sliding = false;
            }
            
            // Apply physics
            player.x += player.vx;
            player.vy += 0.5; // gravity
            player.y += player.vy;
            
            // Ground check
            player.grounded = false;
            
            // Platform collision
            for (let platform of platforms) {
                if (checkCollision(player, platform)) {
                    // Landing on top
                    if (player.vy > 0 && player.y < platform.y) {
                        player.y = platform.y - player.height;
                        player.vy = 0;
                        player.grounded = true;
                        player.jumping = false;
                        
                        // Landing dust
                        if (Math.abs(player.vx) > 1) {
                            particles.push(new Particle(player.x + player.width/2, player.y + player.height, 'dust'));
                        }
                    }
                }
            }
            
            // Crystal collection
            for (let crystal of crystals) {
                if (!crystal.collected && checkCollision(player, crystal)) {
                    crystal.collected = true;
                    score += 10;
                    playSound('collect');
                    
                    // Crystal particles
                    for (let i = 0; i < 8; i++) {
                        particles.push(new Particle(crystal.x + crystal.width/2, crystal.y + crystal.height/2, 'crystal'));
                    }
                }
                crystal.update();
            }
            
            // Spike collision
            for (let spike of spikes) {
                if (checkCollision(player, spike) && !player.sliding) {
                    lives--;
                    player.x = 150;
                    player.y = 300;
                    
                    if (lives <= 0) {
                        gameState = 'gameover';
                        playSound('gameover');
                    }
                }
            }
            
            // World scrolling
            if (player.x > canvas.width * 0.6) {
                let scrollAmount = player.x - canvas.width * 0.6;
                player.x = canvas.width * 0.6;
                
                // Move everything
                platforms.forEach(p => p.x -= scrollAmount);
                crystals.forEach(c => c.x -= scrollAmount);
                spikes.forEach(s => s.x -= scrollAmount);
                particles.forEach(p => p.x -= scrollAmount);
                backgroundOffset += scrollAmount * 0.3;
                
                // Generate new content
                if (Math.random() < 0.02) {
                    let lastPlatform = platforms[platforms.length - 1];
                    platforms.push(new Platform(lastPlatform.x + 200, 300 + Math.random() * 100, 80 + Math.random() * 40, 20));
                }
                
                if (Math.random() < 0.03) {
                    crystals.push(new Crystal(canvas.width + 100, 200 + Math.random() * 150));
                }
                
                if (Math.random() < 0.02) {
                    spikes.push(new Spike(canvas.width + 100, 375));
                }
            }
            
            // Keep player in bounds
            if (player.x < 0) player.x = 0;
            if (player.y > canvas.height) {
                lives--;
                player.x = 150;
                player.y = 300;
                
                if (lives <= 0) {
                    gameState = 'gameover';
                    playSound('gameover');
                }
            }
            
            // Update particles
            particles = particles.filter(p => p.life > 0);
            particles.forEach(p => p.update());
            
            // Increase difficulty
            if (frameCount % 500 === 0) {
                gameSpeed += 0.2;
            }
            
            // Animation
            player.animFrame += 0.2;
        }
        
        // Draw background
        function drawBackground() {
            // Sky gradient
            let gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#0a1551');
            gradient.addColorStop(0.5, '#1e3c72');
            gradient.addColorStop(1, '#2a5298');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Mountains (far background)
            ctx.fillStyle = 'rgba(30, 30, 60, 0.5)';
            for (let i = 0; i < 5; i++) {
                let x = i * 250 - (backgroundOffset * 0.1) % (250 * 5);
                ctx.beginPath();
                ctx.moveTo(x, canvas.height);
                ctx.lineTo(x + 125, 150);
                ctx.lineTo(x + 250, canvas.height);
                ctx.fill();
            }
            
            // Temple pillars (mid background)
            ctx.fillStyle = 'rgba(60, 60, 80, 0.7)';
            for (let i = 0; i < 10; i++) {
                let x = i * 150 - (backgroundOffset * 0.5) % (150 * 10);
                ctx.fillRect(x, 100, 30, 300);
                // Pillar tops
                ctx.fillRect(x - 5, 95, 40, 15);
            }
            
            // Torches
            for (let i = 0; i < 8; i++) {
                let x = i * 200 - (backgroundOffset * 0.7) % (200 * 8);
                
                // Torch holder
                ctx.fillStyle = '#654321';
                ctx.fillRect(x, 250, 10, 30);
                
                // Flame
                ctx.fillStyle = '#ff6600';
                ctx.beginPath();
                ctx.arc(x + 5, 245, 8 + Math.sin(frameCount * 0.1 + i) * 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Inner flame
                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.arc(x + 5, 247, 4 + Math.sin(frameCount * 0.15 + i) * 1, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Draw player
        function drawPlayer() {
            ctx.save();
            
            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.ellipse(player.x + player.width/2, player.y + player.height + 5, player.width/2, 5, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Player body
            if (player.sliding) {
                // Sliding pose
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(player.x, player.y + 20, player.width + 10, player.height - 20);
            } else {
                // Body
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(player.x + 5, player.y + 10, player.width - 10, player.height - 15);
                
                // Head
                ctx.fillStyle = '#DEB887';
                ctx.beginPath();
                ctx.arc(player.x + player.width/2, player.y + 8, 8, 0, Math.PI * 2);
                ctx.fill();
                
                // Arms (animated)
                ctx.strokeStyle = '#8B4513';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(player.x + 7, player.y + 15);
                ctx.lineTo(player.x + 2, player.y + 25 + Math.sin(player.animFrame) * 5);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(player.x + player.width - 7, player.y + 15);
                ctx.lineTo(player.x + player.width - 2, player.y + 25 + Math.sin(player.animFrame + Math.PI) * 5);
                ctx.stroke();
                
                // Legs (animated)
                ctx.beginPath();
                ctx.moveTo(player.x + 10, player.y + player.height - 5);
                ctx.lineTo(player.x + 8, player.y + player.height + Math.sin(player.animFrame) * 3);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(player.x + player.width - 10, player.y + player.height - 5);
                ctx.lineTo(player.x + player.width - 8, player.y + player.height + Math.sin(player.animFrame + Math.PI) * 3);
                ctx.stroke();
            }
            
            ctx.restore();
        }
        
        // Draw HUD
        function drawHUD() {
            // Score
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(canvas.width - 150, 10, 140, 40);
            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 20px Courier New';
            ctx.fillText(`üíé Score: ${score}`, canvas.width - 140, 35);
            
            // Lives
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(10, 10, 150, 40);
            ctx.fillStyle = '#FF6B6B';
            ctx.font = 'bold 20px Courier New';
            ctx.fillText('‚ù§Ô∏è Lives: ', 20, 35);
            for (let i = 0; i < lives; i++) {
                ctx.fillText('‚ù§Ô∏è', 110 + i * 25, 35);
            }
            
            // Controls hint (bottom left, semi-transparent)
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(10, canvas.height - 60, 200, 50);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.font = '12px Courier New';
            ctx.fillText('‚Üë Jump  ‚Üì Slide', 20, canvas.height - 40);
            ctx.fillText('‚Üê ‚Üí Move  ESC Pause', 20, canvas.height - 20);
        }
        
        // Game over screen
        function drawGameOver() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#FF0000';
            ctx.font = 'bold 60px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2 - 50);
            
            ctx.fillStyle = '#FFD700';
            ctx.font = '30px Courier New';
            ctx.fillText(`Final Score: ${score}`, canvas.width/2, canvas.height/2 + 20);
            
            ctx.fillStyle = '#FFFFFF';
            ctx.font = '20px Courier New';
            ctx.fillText('Press F5 to restart', canvas.width/2, canvas.height/2 + 70);
            
            ctx.textAlign = 'left';
        }
        
        // Pause screen
        function drawPause() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#FFFF00';
            ctx.font = 'bold 50px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('PAUSED', canvas.width/2, canvas.height/2);
            
            ctx.fillStyle = '#FFFFFF';
            ctx.font = '20px Courier New';
            ctx.fillText('Press ESC to continue', canvas.width/2, canvas.height/2 + 40);
            
            ctx.textAlign = 'left';
        }
        
        // Main game loop
        function gameLoop() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw everything
            drawBackground();
            
            // Draw game objects
            platforms.forEach(p => p.draw());
            crystals.forEach(c => c.draw());
            spikes.forEach(s => s.draw());
            particles.forEach(p => p.draw());
            
            drawPlayer();
            drawHUD();
            
            // Update game
            update();
            
            // Draw overlay screens
            if (gameState === 'paused') {
                drawPause();
            } else if (gameState === 'gameover') {
                drawGameOver();
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        // Initialize and start game
        initLevel();
        
        // Start game when user interacts (for audio)
        document.addEventListener('click', () => {
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }, { once: true });
        
        gameLoop();
    </script>
</body>
</html>
