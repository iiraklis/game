<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Cyber Survival</title>
    <style>
        body { margin: 0; overflow: hidden; background: black; font-family: monospace; }
        canvas { display: block; }
        .screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.8); color: #00ffff; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 10; }
        .screen h1 { font-size: 3em; text-shadow: 0 0 10px #ff00ff; }
        .screen button { background: #ff00ff; border: 2px solid #00ffff; color: black; font-size: 1.5em; padding: 10px 20px; margin: 10px; cursor: pointer; text-shadow: 0 0 5px black; }
        .screen button:hover { background: #00ffff; color: #ff00ff; }
        .screen p { max-width: 80%; text-align: center; font-size: 1.2em; }
        .screen input[type="range"] { width: 200px; }
        .screen label { font-size: 1.2em; }
        #pauseScreen { background: rgba(0, 0, 0, 0.5); }
        #hud { position: absolute; top: 10px; left: 10px; color: #00ffff; font-size: 1.5em; z-index: 5; display: none; }
        @media (max-width: 600px) { .screen h1 { font-size: 2em; } .screen button { font-size: 1em; padding: 5px 10px; } }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="titleScreen" class="screen">
        <h1>Neon Cyber Survival</h1>
        <button onclick="showLevelSelect()">Play / Continue</button>
        <button onclick="showSettings()">Settings</button>
        <button onclick="showHowToPlay()">How to Play</button>
    </div>
    <div id="howToPlayScreen" class="screen" style="display:none;">
        <h1>How to Play</h1>
        <p>In this cyber city survival game, navigate your avatar through neon grids, collect data orbs while avoiding chasing AI drones. Use time-slow to dodge and collect efficiently.</p>
        <p>Desktop Controls: WASD/Arrows to move, Space to activate time-slow (when energy full), Shift for dash, Esc to pause.</p>
        <p>Mobile Controls: Touch left side for joystick movement, tap right side for time-slow, double-tap right for dash.</p>
        <p>Objective: Collect required orbs without getting hit too many times. Survive and score high with combos!</p>
        <p>About: Daily Seed - 2026-02-11. Theme: Cyber City, Ability: Time-Slow, Objective: Survive & Collect, Enemies: AI Chase.</p>
        <p>Tips: Time-slow recharges with orbs. Dash for quick escapes. Build combos by collecting without hits.</p>
        <button onclick="backToTitle()">Back</button>
    </div>
    <div id="settingsScreen" class="screen" style="display:none;">
        <h1>Settings</h1>
        <label>Music Volume: <input type="range" id="musicVol" min="0" max="1" step="0.1" value="0.5" oninput="setMusicVolume(this.value)"></label>
        <label>SFX Volume: <input type="range" id="sfxVol" min="0" max="1" step="0.1" value="0.5" oninput="setSfxVolume(this.value)"></label>
        <label>Mute: <input type="checkbox" id="mute" onchange="toggleMute(this.checked)"></label>
        <label>Reduced Motion: <input type="checkbox" id="reducedMotion" onchange="toggleReducedMotion(this.checked)"></label>
        <label>High Contrast: <input type="checkbox" id="highContrast" onchange="toggleHighContrast(this.checked)"></label>
        <button onclick="backToTitle()">Back</button>
    </div>
    <div id="levelSelectScreen" class="screen" style="display:none;">
        <h1>Level Select</h1>
        <div id="levels"></div>
        <button onclick="backToTitle()">Back</button>
    </div>
    <div id="endScreen" class="screen" style="display:none;">
        <h1 id="endTitle">Level Complete!</h1>
        <p id="endStats"></p>
        <button onclick="nextLevelOrTitle()">Next Level / Menu</button>
        <button onclick="restartLevel()">Restart</button>
    </div>
    <div id="pauseScreen" class="screen" style="display:none;">
        <h1>Paused</h1>
        <button onclick="resumeGame()">Resume</button>
        <button onclick="restartLevel()">Restart</button>
        <button onclick="showLevelSelect()">Level Select</button>
        <button onclick="window.location.href='../index.html'">Main Menu</button>
    </div>
    <div id="hud"></div>
    <script>
        // === Code Quality: Organized sections ===
        // 1. Constants and Globals
        // 2. Utility Functions (PRNG, Hash)
        // 3. Save/Load
        // 4. Sound System
        // 5. Input Handling
        // 6. Game Logic (Update, Entities)
        // 7. Drawing
        // 8. Screens and State Management
        // 9. Init and Loop

        // 1. Constants and Globals
        const DATE = '2026-02-11';
        const GAME_WIDTH = 800;
        const GAME_HEIGHT = 600;
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let scaleX, scaleY;
        const keys = {};
        const touches = {};
        let joystick = { active: false, startX: 0, startY: 0, dx: 0, dy: 0 };
        let actionTouch = false;
        let dashTouchTime = 0;
        let gameState = 'title';
        let currentLevel = 1;
        let unlockedLevel = 1;
        let bestScores = new Array(11).fill(0); // Levels 1-10
        let settings = { musicVol: 0.5, sfxVol: 0.5, mute: false, reducedMotion: false, highContrast: false };
        let audioCtx;
        let musicGain, sfxGain;
        let musicPlaying = false;
        let player = { x: GAME_WIDTH / 2, y: GAME_HEIGHT / 2, speed: 300, health: 3, energy: 100, maxEnergy: 100, timeSlowActive: false, timeSlowDuration: 2, timeSlowTimer: 0, cooldown: 5, cooldownTimer: 0, dashTimer: 0, dashDuration: 0.2, dashSpeed: 600 };
        let enemies = [];
        let orbs = [];
        let particles = [];
        let score = 0;
        let combo = 0;
        let shake = 0;
        let gameTime = 0;
        let gameSpeed = 1;
        let paused = false;
        let achievements = { perfectLevels: 0, maxCombo: 0 }; // Simple tracking
        const levels = [
            { enemies: 1, orbs: 3, timeLimit: 60 }, // Basic
            { enemies: 2, orbs: 4, timeLimit: 60 },
            { enemies: 2, orbs: 5, timeLimit: 60 }, // Introduce time-slow
            { enemies: 3, orbs: 6, timeLimit: 50 },
            { enemies: 3, orbs: 7, timeLimit: 50 }, // Add dash
            { enemies: 4, orbs: 8, timeLimit: 40 },
            { enemies: 4, orbs: 9, timeLimit: 40 }, // Combine
            { enemies: 5, orbs: 10, timeLimit: 30 },
            { enemies: 5, orbs: 11, timeLimit: 30 },
            { enemies: 6, orbs: 12, timeLimit: 20 } // Boss-like: faster enemies
        ];

        // 2. Utility Functions
        function hash(str) {
            let h = 0;
            for (let i = 0; i < str.length; i++) {
                h = ((h << 5) - h + str.charCodeAt(i)) | 0;
            }
            return h >>> 0;
        }
        const SEED = hash(DATE);
        function PRNG(seed) {
            let state = seed;
            return function() {
                state = (state * 1664525 + 1013904223) % 4294967296;
                return state / 4294967296;
            };
        }

        // 3. Save/Load
        function loadSave() {
            const save = localStorage.getItem('neonCyberSurvival');
            if (save) {
                const data = JSON.parse(save);
                unlockedLevel = data.unlockedLevel || 1;
                bestScores = data.bestScores || new Array(11).fill(0);
                settings = data.settings || { musicVol: 0.5, sfxVol: 0.5, mute: false, reducedMotion: false, highContrast: false };
            }
            updateSettingsUI();
        }
        function saveProgress() {
            localStorage.setItem('neonCyberSurvival', JSON.stringify({ unlockedLevel, bestScores, settings }));
        }

        // 4. Sound System
        function initAudio() {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            musicGain = audioCtx.createGain();
            musicGain.gain.value = settings.musicVol;
            sfxGain = audioCtx.createGain();
            sfxGain.gain.value = settings.sfxVol;
            musicGain.connect(audioCtx.destination);
            sfxGain.connect(audioCtx.destination);
            if (!settings.mute) startMusic();
        }
        function startMusic() {
            if (musicPlaying || settings.mute) return;
            musicPlaying = true;
            // Procedural background music: simple cyber synth loop
            const notes = [440, 494, 523, 587, 659, 698, 784, 880]; // A minor scale
            let index = 0;
            const playNote = () => {
                if (!musicPlaying) return;
                const osc = audioCtx.createOscillator();
                osc.type = 'sawtooth';
                osc.frequency.value = notes[index % notes.length];
                const env = audioCtx.createGain();
                env.gain.value = 0;
                env.gain.linearRampToValueAtTime(0.2, audioCtx.currentTime + 0.01);
                env.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3);
                osc.connect(env).connect(musicGain);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.3);
                index++;
                setTimeout(playNote, 300 + Math.sin(index) * 50); // Slight variation
            };
            playNote();
        }
        function stopMusic() {
            musicPlaying = false;
        }
        function playSFX(type) {
            if (settings.mute) return;
            const osc = audioCtx.createOscillator();
            if (type === 'collect') {
                osc.type = 'sine';
                osc.frequency.value = 880;
            } else if (type === 'hit') {
                osc.type = 'square';
                osc.frequency.value = 220;
            } else if (type === 'slow') {
                osc.type = 'sawtooth';
                osc.frequency.value = 440;
            } else if (type === 'dash') {
                osc.type = 'triangle';
                osc.frequency.value = 660;
            }
            const env = audioCtx.createGain();
            env.gain.value = 0.5;
            env.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.1);
            osc.connect(env).connect(sfxGain);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.1);
        }
        function setMusicVolume(val) {
            settings.musicVol = parseFloat(val);
            musicGain.gain.value = val;
            saveProgress();
        }
        function setSfxVolume(val) {
            settings.sfxVol = parseFloat(val);
            sfxGain.gain.value = val;
            saveProgress();
        }
        function toggleMute(checked) {
            settings.mute = checked;
            if (checked) {
                stopMusic();
            } else {
                startMusic();
            }
            saveProgress();
        }
        function toggleReducedMotion(checked) {
            settings.reducedMotion = checked;
            saveProgress();
        }
        function toggleHighContrast(checked) {
            settings.highContrast = checked;
            saveProgress();
        }
        function updateSettingsUI() {
            document.getElementById('musicVol').value = settings.musicVol;
            document.getElementById('sfxVol').value = settings.sfxVol;
            document.getElementById('mute').checked = settings.mute;
            document.getElementById('reducedMotion').checked = settings.reducedMotion;
            document.getElementById('highContrast').checked = settings.highContrast;
        }

        // 5. Input Handling
        window.addEventListener('keydown', e => { keys[e.key] = true; if (e.key === 'Escape' && gameState === 'game') togglePause(); });
        window.addEventListener('keyup', e => { keys[e.key] = false; });
        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            for (let touch of e.changedTouches) {
                if (touch.pageX < window.innerWidth / 2) {
                    joystick.active = true;
                    joystick.startX = touch.pageX;
                    joystick.startY = touch.pageY;
                } else {
                    if (actionTouch && performance.now() - dashTouchTime < 300) {
                        player.dashTimer = player.dashDuration;
                        playSFX('dash');
                    } else {
                        actionTouch = true;
                        dashTouchTime = performance.now();
                    }
                    if (player.energy >= 50 && player.cooldownTimer <= 0) {
                        player.timeSlowActive = true;
                        player.timeSlowTimer = player.timeSlowDuration;
                        player.cooldownTimer = player.cooldown;
                        player.energy -= 50;
                        playSFX('slow');
                    }
                }
            }
        });
        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            for (let touch of e.changedTouches) {
                if (joystick.active && touch.pageX < window.innerWidth / 2) {
                    joystick.dx = touch.pageX - joystick.startX;
                    joystick.dy = touch.pageY - joystick.startY;
                }
            }
        });
        canvas.addEventListener('touchend', e => {
            e.preventDefault();
            for (let touch of e.changedTouches) {
                if (touch.pageX < window.innerWidth / 2) {
                    joystick.active = false;
                    joystick.dx = 0;
                    joystick.dy = 0;
                } else {
                    actionTouch = false;
                }
            }
        });

        // 6. Game Logic
        function startLevel(level) {
            currentLevel = level;
            player.x = GAME_WIDTH / 2;
            player.y = GAME_HEIGHT / 2;
            player.health = 3;
            player.energy = 100;
            player.timeSlowActive = false;
            player.timeSlowTimer = 0;
            player.cooldownTimer = 0;
            player.dashTimer = 0;
            enemies = [];
            orbs = [];
            particles = [];
            score = 0;
            combo = 0;
            gameTime = 0;
            const lvlData = levels[level - 1];
            const rng = PRNG(SEED + level);
            for (let i = 0; i < lvlData.enemies; i++) {
                enemies.push({ x: rng() * GAME_WIDTH, y: rng() * GAME_HEIGHT, speed: 100 + level * 10 });
            }
            spawnOrbs(lvlData.orbs);
            gameState = 'game';
            hideAllScreens();
            document.getElementById('hud').style.display = 'block';
            paused = false;
        }
        function spawnOrbs(count) {
            const rng = PRNG(SEED + currentLevel + orbs.length);
            for (let i = 0; i < count; i++) {
                orbs.push({ x: rng() * GAME_WIDTH, y: rng() * GAME_HEIGHT });
            }
        }
        function update(delta) {
            if (paused) return;
            gameTime += delta;
            const lvlData = levels[currentLevel - 1];
            if (gameTime > lvlData.timeLimit || player.health <= 0) {
                endLevel(false);
                return;
            }
            if (orbs.length === 0) {
                endLevel(true);
                return;
            }

            // Player movement
            let dx = 0, dy = 0;
            let pSpeed = player.speed;
            if (player.dashTimer > 0) {
                player.dashTimer -= delta;
                pSpeed = player.dashSpeed;
            }
            if (keys['ArrowLeft'] || keys['a'] || keys['A']) dx -= 1;
            if (keys['ArrowRight'] || keys['d'] || keys['D']) dx += 1;
            if (keys['ArrowUp'] || keys['w'] || keys['W']) dy -= 1;
            if (keys['ArrowDown'] || keys['s'] || keys['S']) dy += 1;
            if (joystick.active) {
                const dist = Math.sqrt(joystick.dx ** 2 + joystick.dy ** 2);
                if (dist > 20) {
                    dx = joystick.dx / dist;
                    dy = joystick.dy / dist;
                }
            }
            const len = Math.sqrt(dx ** 2 + dy ** 2);
            if (len > 0) {
                dx /= len;
                dy /= len;
            }
            player.x += dx * pSpeed * delta;
            player.y += dy * pSpeed * delta;
            player.x = Math.max(0, Math.min(GAME_WIDTH, player.x));
            player.y = Math.max(0, Math.min(GAME_HEIGHT, player.y));

            // Time slow
            gameSpeed = 1;
            if (player.timeSlowActive) {
                player.timeSlowTimer -= delta;
                if (player.timeSlowTimer <= 0) player.timeSlowActive = false;
                gameSpeed = 0.3;
            }
            if (player.cooldownTimer > 0) player.cooldownTimer -= delta;
            player.energy = Math.min(player.maxEnergy, player.energy + 10 * delta); // Recharge

            // Enemies
            enemies.forEach(enemy => {
                const ex = player.x - enemy.x;
                const ey = player.y - enemy.y;
                const elen = Math.sqrt(ex ** 2 + ey ** 2);
                if (elen > 0) {
                    enemy.x += (ex / elen) * enemy.speed * delta * gameSpeed;
                    enemy.y += (ey / elen) * enemy.speed * delta * gameSpeed;
                }
                // Collision with player
                if (Math.hypot(player.x - enemy.x, player.y - enemy.y) < 20) {
                    player.health--;
                    shake = 10;
                    combo = 0;
                    playSFX('hit');
                    if (!settings.reducedMotion) addParticles(enemy.x, enemy.y, 'red');
                }
            });

            // Orbs
            orbs = orbs.filter(orb => {
                if (Math.hypot(player.x - orb.x, player.y - orb.y) < 15) {
                    score += 10 * (combo + 1);
                    combo++;
                    player.energy = Math.min(player.maxEnergy, player.energy + 20);
                    playSFX('collect');
                    if (!settings.reducedMotion) addParticles(orb.x, orb.y, '#00ff00');
                    return false;
                }
                return true;
            });

            // Particles
            particles = particles.filter(p => {
                p.life -= delta;
                p.x += p.vx * delta * gameSpeed;
                p.y += p.vy * delta * gameSpeed;
                return p.life > 0;
            });

            // Keys for actions
            if ((keys[' '] || actionTouch) && player.energy >= 50 && player.cooldownTimer <= 0 && !player.timeSlowActive) {
                player.timeSlowActive = true;
                player.timeSlowTimer = player.timeSlowDuration;
                player.cooldownTimer = player.cooldown;
                player.energy -= 50;
                playSFX('slow');
            }
            if (keys['Shift'] && player.dashTimer <= 0) {
                player.dashTimer = player.dashDuration;
                playSFX('dash');
            }
        }
        function addParticles(x, y, color) {
            for (let i = 0; i < 10; i++) {
                particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 200,
                    vy: (Math.random() - 0.5) * 200,
                    life: 0.5,
                    color,
                    size: 5
                });
            }
        }
        function endLevel(win) {
            gameState = 'end';
            document.getElementById('endTitle').innerText = win ? 'Level Complete!' : 'Game Over';
            document.getElementById('endStats').innerText = `Score: ${score}\nCombo: ${combo}\nHealth: ${player.health}`;
            if (win) {
                if (score > bestScores[currentLevel]) bestScores[currentLevel] = score;
                if (currentLevel + 1 > unlockedLevel) unlockedLevel = currentLevel + 1;
                if (player.health === 3) achievements.perfectLevels++;
                if (combo > achievements.maxCombo) achievements.maxCombo = combo;
                saveProgress();
            }
            document.getElementById('endScreen').style.display = 'flex';
        }
        function togglePause() {
            paused = !paused;
            document.getElementById('pauseScreen').style.display = paused ? 'flex' : 'none';
            if (paused) stopMusic(); else startMusic();
        }

        // 7. Drawing
        function resize() {
            const dpr = window.devicePixelRatio || 1;
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;
            canvas.style.width = window.innerWidth + 'px';
            canvas.style.height = window.innerHeight + 'px';
            scaleX = canvas.width / GAME_WIDTH;
            scaleY = canvas.height / GAME_HEIGHT;
        }
        function draw() {
            ctx.save();
            ctx.scale(scaleX, scaleY);
            if (shake > 0 && !settings.reducedMotion) {
                ctx.translate((Math.random() - 0.5) * shake, (Math.random() - 0.5) * shake);
                shake *= 0.9;
            }
            ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

            // Background: Neon grid
            ctx.strokeStyle = settings.highContrast ? '#ffffff' : '#00ffff';
            ctx.lineWidth = 1;
            for (let i = 0; i < GAME_WIDTH; i += 50) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, GAME_HEIGHT);
                ctx.stroke();
            }
            for (let i = 0; i < GAME_HEIGHT; i += 50) {
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(GAME_WIDTH, i);
                ctx.stroke();
            }

            // Player
            ctx.fillStyle = settings.highContrast ? '#ffffff' : '#ff00ff';
            ctx.beginPath();
            ctx.arc(player.x, player.y, 10, 0, Math.PI * 2);
            ctx.fill();
            if (player.timeSlowActive && !settings.reducedMotion) {
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            // Enemies
            enemies.forEach(enemy => {
                ctx.fillStyle = settings.highContrast ? '#000000' : '#ff0000';
                ctx.beginPath();
                ctx.arc(enemy.x, enemy.y, 10, 0, Math.PI * 2);
                ctx.fill();
            });

            // Orbs
            orbs.forEach(orb => {
                ctx.fillStyle = settings.highContrast ? '#aaaaaa' : '#00ff00';
                ctx.beginPath();
                ctx.arc(orb.x, orb.y, 8, 0, Math.PI * 2);
                ctx.fill();
            });

            // Particles
            if (!settings.reducedMotion) {
                particles.forEach(p => {
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size * (p.life / 0.5), 0, Math.PI * 2);
                    ctx.fill();
                });
            }

            // HUD on canvas? No, use DOM hud
            const hud = document.getElementById('hud');
            hud.innerHTML = `Level: ${currentLevel} | Score: ${score} | Combo: ${combo} | Health: ${player.health} | Energy: ${Math.floor(player.energy)} | Orbs Left: ${orbs.length} | Time: ${Math.floor(levels[currentLevel-1].timeLimit - gameTime)}`;

            ctx.restore();
        }

        // 8. Screens and State Management
        function hideAllScreens() {
            document.querySelectorAll('.screen').forEach(s => s.style.display = 'none');
            document.getElementById('hud').style.display = 'none';
        }
        function showTitle() {
            gameState = 'title';
            hideAllScreens();
            document.getElementById('titleScreen').style.display = 'flex';
        }
        function showHowToPlay() {
            hideAllScreens();
            document.getElementById('howToPlayScreen').style.display = 'flex';
        }
        function showSettings() {
            hideAllScreens();
            document.getElementById('settingsScreen').style.display = 'flex';
        }
        function showLevelSelect() {
            hideAllScreens();
            const levelsDiv = document.getElementById('levels');
            levelsDiv.innerHTML = '';
            for (let i = 1; i <= 10; i++) {
                const btn = document.createElement('button');
                btn.innerText = `Level ${i} (Best: ${bestScores[i]})`;
                btn.disabled = i > unlockedLevel;
                btn.onclick = () => startLevel(i);
                levelsDiv.appendChild(btn);
            }
            document.getElementById('levelSelectScreen').style.display = 'flex';
        }
        function backToTitle() {
            showTitle();
        }
        function resumeGame() {
            togglePause();
        }
        function restartLevel() {
            startLevel(currentLevel);
        }
        function nextLevelOrTitle() {
            if (currentLevel < 10) {
                startLevel(currentLevel + 1);
            } else {
                showTitle();
            }
        }

        // 9. Init and Loop
        window.addEventListener('resize', resize);
        resize();
        loadSave();
        initAudio();
        let lastTime = 0;
        function loop(time) {
            const delta = (time - lastTime) / 1000;
            lastTime = time;
            if (gameState === 'game') {
                update(delta);
                draw();
            }
            requestAnimationFrame(loop);
        }
        requestAnimationFrame(loop);
    </script>
</body>
</html>
